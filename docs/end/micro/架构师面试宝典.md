# 架构师-面试宝典

## 1. 设计模式

### 设计模式的六大原则 ？

> 答：开闭原则、 合成复用原则、 依赖倒置原则、 接口隔离原则、 里氏替换原则、 迪米特原则

### 设计模式分为几种 ？ 详细列出具体的。

> 答: 创建模式、行为模式、结构模式
> 1. （5）创建模式：单例模式、工厂模式、 抽象工厂模式、 构建者模式
> 2. （8）结构模式：适配器模式、装饰者模式
> 2. （12）行为模式：代理模式、策略模式、状态模式、责任链模式、状态模式、模板模式


### 1.1 二十三种设计模式

#### 1.1.1 创建型

1. ##### 工厂模式（Factory Pattern）

   - ###### 什么是工厂模式 ？
   
   > 答： 


2. ##### 单例模式（Singleton Pattern）

   - ###### 什么是单例模式 ？
   
   > 答： 在 jvm 运行中只存在一个实例对象。
  
   - ###### 应用场景？                                                               
    
   > 答：比如：Spring 默认注入对象启动时、 线程池、 任务管理器、 垃圾箱、 日志收集、 共享文件

   - ###### 单例模式有哪些创建方式 ？
   
   > 答：5种， 分别：
   > 1. 懒汉 
   > 2. 饿汉
   > 3. 內部类
   > 4. 枚举                                                                                                                          
   > 5. 双重检验锁                                                                                                                          
                                                                                                                          
   - ###### 饿汉式和懒汉式区别 ？
   
   > 答：1. 饿汉式: 在程序启动时，将对象初始化对中去，立即加载; 它是使用 static静态常量和final修饰初始化对象。
   > a. 优点：1.线程安全 2. 效率高                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
   > b. 缺点：1.当对象没有被使用时，占用内存资源。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
   > 2.懒汉式：当对象需要被使用时，才创建对象，所以也叫做延迟加载。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
   > a. 优点：1.延迟加载, 合理分配资源。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
   > b. 缺点：1.线程不安全 2. 效率比较低, 原因是因为使用了synchronized 锁。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
   - ###### 如何破环一个单例 ？
   
   > 答： 通过反射获取对象，通过获取对象方法、构造函数、属性，进行创建对象。
   >  防止破环单例：使用一个标识符，进行作为全局变量，当标识符为true时，相当于进行上锁，当第二次调用时，抛出异常防止单例被破坏。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

   - ###### Java 序列化作用和序列化协议有哪些？

   - ###### 哪种单例模式最安全 ？
   
   > 答： 饿汉、枚举、静态内部类。 不能被反射，因为在反射机制中，不能反射被final类标识的

3. ##### 建造者模式（Builder Pattern）

4. ##### 原型模式（Prototype Pattern）

#### 1.1.2 行为型

5. ##### 适配器模式（Adapter Pattern）

6. ##### 桥接模式（Bridge Pattern）

7. #####  过滤器模式（Filter、Criteria Pattern）

8. #####  组合模式（Composite Pattern）

9. #####  装饰器模式（Decorator Pattern）

10. #####  外观模式（Facade Pattern）

11. #####  享元模式（Flyweight Pattern）

12. #####  代理模式（Proxy Pattern）

#### 1.1.3 结构型

13. ##### 责任链模式（Chain of Responsibility Pattern）

14. ##### 命令模式（Command Pattern）

15. ##### 解释器模式（Interpreter Pattern）

16. ##### 迭代器模式（Iterator Pattern） 

17. ##### 备忘录模式（Memento Pattern）  

18. #####  观察者模式（Observer Pattern）

19. ##### 状态模式（State Pattern）  

20. ##### 空对象模式（Null Object Pattern）  

21. ##### 策略模式（Strategy Pattern） 

22. ##### 模板模式（Template Pattern） 

23. #####  访问者模式（Visitor Pattern）

## 2. 并发编程

### 2.1 多线程

- #### 为什么要使用多线程 ？

- #### 项目中哪些地方使用到多线程 ？

- #### 多线程如何获取异步处理结果 ？

-  #### 多线程处理技术中会遇到哪些问题 ？

### 2.2 线程池

- #### 你有用过线程池 ？

- #### 线程池有哪些优点 ？

- #### 线程池有哪些创建方式 ？

- #### 线程池核心原理 ？

## 3. 集合框架源码分析

### 3.1 ArrayList 

- #### 原理分析 ？

- #### 数组、链表分表有 哪些特性 ?

- #### Add方法实现原理 ？

- #### 底层如果实现扩容 ？

- #### 默认扩容多少倍 ？

- #### 底层删除的原理 ？

- #### 线程是否安全 ？

- #### 为什么开始扩容是50% ？

- #### ModCount ++ 作用 ？

- #### fail-fast 的产生 ？

- #### Vector 与Arraylist有 哪些区别 ？

### 3.2 CopyOnWriteArrayList 

- #### Add方法底层实现 ？

- #### CopyOnWriteArrayList与ArrayList实现的区别 ？

### 3.3 HashSet

- #### 集合底层是如何实现的 ?

- #### 底层如何保证Key不允许重复 ?

### 3.4 HashMap

- #### 实现的原理 ?

- #### HashEntry对象的作用有 哪些 ?

- #### HashCode与equals之间的区别 ?

- #### 如果我们重写了equals方法之后，一定要重写HashCode 为什么 ?

- #### HashMap与HashTable有 哪些区别 ?

- #### 如何理解HashCode碰撞问题 ?

- #### 1.7

  - ##### put方法是如何实现 ?

  - ##### 扩容如何实现的呢 ？

  - ##### 为什么要使用链表？

  - ##### get方法深度源码分析 ?

  - ##### 添加Key为空的情况下如何存放 ?

  - ##### 为什么中h & (length-1) length需要-1 ?

  - ##### 底层是如何实现扩容 ?

  - ##### 为什么加载因子为0.75 ? 

  - ##### 扩容的时候存在哪些缺点 ?

  - ##### 如何计算HashCode ?

- #### 1.8

  - ##### 为什么要使用红黑树 ? 

  - ##### 如何将链表转换红黑树 ?

  - ##### 时间复杂度O(1)、O(N)、O(Log n)区别 ?

  - ##### 根据key时间复杂度为多少 ?

  - ##### 二叉搜索树存在哪些优缺点 ?

  - ##### 红黑树时间复杂度是多少？旋转、变色规则 ?

  - ##### 1.8与1.7实现有 哪些区别 ?

  

## 4. 核心框架源码分析

### 4.1 Servlet 的原理

### 4.2 Spring 的原理

### 4.3 SpringMVC 的原理

### 4.4 SpringBoot 的原理



## 5. 高并发 

### 5.1 高并发产生的问题 ？

### 5.2 高并发解决方案有哪些 ？

- WEB前端
- 后端

## 6. 高可用

### 6.1 NGINX

- #### 什么是 NGINX ?

- #### NGINX 的作用 ？

### 6.2 LVS 

- #### 什么是LVS  ？

- #### LVS 基本作用  ？

### 6.3 KeepAlived

- #### 什么是KeepAlived ？

- #### KeepAlived 的作用 ？

### 6.4 服务器集群会产生的问题 ？



## 7. 网络通讯技术

### 7.1 OSI七层网络模型的介绍

### 7.2 HTTP 协议长连接与短连接的区别

### 7.3 HTTP 与 HTTPS 的区别

### 7.4 DNS 域名解析的过程

### 7.5 如何解决网站跨域的问题

### 7.6 同步和异步的区别

### 7.7 Socket技术中TCP与UDP区别

- #### TCP

  - ##### 什么是TCP ? 

  - ##### 白话文翻译TCP三次握手协议 ?

- #### UDP

  - ##### 什么是UPD ?

  - ##### TCP 与 UPD 区别 ?

### 7.8 Linux五种IO模型

### 7.9 IO 

- #### 阻塞式IO与非阻塞式IO的区别 ?

- #### 使用多线程实现异步IO存在哪些缺点 ?

- #### 使用多线程实现伪异步IO优缺点 ?

### 7.10 BIO

- #### 什么是BIO阻塞式IO介绍 ?

- #### BIO 模型存在哪些缺点 ?

- #### NIO 与 BIO 的区别有哪些 ?

### 7.11 NIO

- #### 为什么要使用 NIO 编程 ?

- #### NIO 模式核心设计技术思想 ?

- #### NIO 技术多路IO复用底层实现原理 ?

- #### NIO 选择器、缓冲区分别核心的作用 ?

### 7.12 Netty

- #### 为什么使用 Netty，不用 NIO ?

- #### Netty 应用场景有哪些 ?

### 7.13 粘包和拆包

- #### 什么是粘包和拆包 ？

- #### 粘包和拆包产生的原因 ？

- #### 如何解决粘包和拆包 ？

### 7.14 序列化与反序列化

- #### 什么是序列化？反序列化 ？

- #### 序列化有哪些实现方式 ？

- #### 网络传输序列化协议有哪些 ？

- #### 网络传输对象为什么需要序列化 ？

### 7.15 MessagePack编码器与json有哪些区别 ?

### 7.16 手写一个Dubbo的思路 ?

### 7.17 手写RPC负载均衡器算法 ?

## 8. 分布式

### 8.1 分布式-Redis 缓存

- #### Redis 的数据类型有哪些  ？

- #### Redis 与 Ehcache 的缓存的区别 ？

- #### 你有用过 Redis吗？Redis 有哪些应用场景 ？

- #### Redis 线程为什么效率这么高 ？

- #### Redis为什么单线程能够支持高并发 ?

- #### Redis 线程线程安全吗 ？

- #### Redis 线程线程安全吗 ？

- #### Redis 分为分为多少个库 ？为什么要分成16个库 ?

- #### Redis 中如何存放对象 ？

- #### MySQL 与 Redis一致性解决方案 ？

- #### 全量同步与增量同步实现的区别 ？

- #### Redis 内存满了，如何处理 ？

- #### Redis 宕机了 ？数据会丢失吗 ？

- #### Redis 持久化中有哪些方案 ？

- #### RDB 与 AOF 同步存在哪些区别 ？

- #### Redis 事务支持回滚吗？

- #### 为什么 Redis 没有回滚事务？

- #### Redis 实现分布式锁的思路？

- #### Redis 中 SetnX 与 Set命令的区别 ？

- #### 在分布式锁中如果超时了？如何处理 ？

- #### Redis 主从复制整个原理过程 ？

- #### 传统一主多从复制存在哪些问题 ？

- #### 哨兵集群架构设计原理 ？

- #### 哨兵如何确定master宕机之后重新选举 ？

- #### Redis 缓存穿透概念与解决方案 ？

- #### Redis 缓存雪崩概念与解决方案 ？

- #### Redis 缓存击穿的解决方案 ？

- #### Redis 集群有哪些方式 ？

- #### RedisCluster 分片集群实现原理 ？

- #### RedisCluster 如何快速扩容和缩容 ？

- #### Redis 集群中主从复制产生了延迟怎么解决 ？

### 8.2 分布式-消息中间件

- #### 传统的 Http 协议调用接口存在哪些问题 ？

- #### 你用用过哪些消息中间件？

- #### 消息中间件可以帮助我们解决哪些问题 ？

- #### Kafka

  - ##### kafka 的设计原理 ？

  - ##### kafka 数据有问题，导致消费端报错，怎么解决 ?

  - ##### kafka 如何实现分区 ?

  - ##### kafka 的Partition Broker、Offset作用有那些 ?

  - ##### kafka 集群如何实现相互感知 ?

- ### MQ 

  - ##### 为什么MQ 可以解决我们的流量的削峰问题 ？

  - ##### MQ  宕机的情况下，消息是否会丢失 ? 

  - ##### MQ  如何保证消息不丢失 ?

  - ##### MQ  如何保证消息的幂等性的问题 ?

  - ##### MQ  服务器端如果消息堆积的情况下如何处理？

  - ##### 投递消息到MQ 服务器端，MQ 服务器已经满了 ?

  - ##### 消费者消费我们的消息报错了？如何处理 ?

  - ##### MQ 突然产生了消息对接？MQ 会崩溃吗？

  - ##### MQ 如果不在的情况下，生产者投递消息会丢失吗？

  - ##### MQ 有多个消费者消费，会重复消费吗？

  - ##### RabbitMQ

    - ###### RabbitMQ  常用的队列模型有哪些 ？

    - ###### RabbitMQ 如何实现消息确认的机制？

    - ###### RabbitMQ 如何保证消息不丢失 ?

    - ###### RabbitMQ 如何实现公平队列 ?

    - ###### RabbitMQ 交换机的作用 ?

    - ###### RabbitMQ 如何实现消息确认的机制？

    - ###### 消息中间件产生了消息堆积如何解决 ?

    - ###### RabbitMQ 如何保证消息不丢失 ?

    - ###### 消息中间件产生了消息堆积如何解决 ?

    - ###### RabbitMQ 如何保证消息不丢失 ?

    - ###### 死信队列的作用与应用场景 ?

    - ###### RabbitMQ 异步如何获取消费结果 ?

    - ###### RabbitMQ 如何解决分布式事务 ?

    - ###### 订单30分钟超时有那些实现方案 ?
  
    - ###### RabbitMQ 如何保证消费者幂等问题 ?

### 8.3 分布式-协调工具Zookeeper

- #### Zookeeper 实际案例中的应用场景 ?

- #### Zookeeper 基本的实现的特征 ?

- #### Zookeeper 节点有那些类型 ?

- #### Zookeeper 节点ACL权限控制 ?

- #### Zookeeper 如何实现分布式锁 ?

- #### 分布式锁中代码出现业务逻辑问题，导致一直不释放锁？人员和解决？

- #### 一致性的原理有那些 ?

- #### 分布式基本一致性概念 ?

- #### Zookeeper 选举的策略 ?

- #### 为什么 Zookeeper 集群节点一定要是奇数 ?

- #### Zookeeper 如何保证节点一致性问题 ?

- #### Zookeeper 如果在后期新增zk节点时如何提高选举效率问题 ?

- #### ZookeeperZab 一致性协议原理 ?

- #### Zookeeper 集群节点如何保证数据同步问题 ?



### 8.4 分布式-数据存储

### 8.5 分布式-事务的解决

## 9. 微服务

###  9.1 微服务架构如何演变的？

### 9.2 从传统到微服务架构过程

### 9.3  微服务架构与SOA架构的区别 ?

### 9.4 微服务架构架构模式的优缺点 ?

### 9.5 SpringCloud第一代 与 二代的区别 ?

### 9.6 微服务架构架构模式中会遇到那些问题

### 9.7 微服务架构中服务治理核心概念

### 9.8 分布式注册中心设计原理

### 9.9 Nacos与Eureka、Zookeeper的区别

### 9.10 discoveryClient的作用有那些

### 9.11 本地负载均衡的实现原理

### 9.12 本地负载均衡与Nginx 的区别

### 9.13 LoadBalancedClient的作用

### 9.14 openfeign客户端与feign客户端区别

### 9.15 使用opfeign为何要继承接口

### 9.16 分布式配置中心产生的背景

### 9.17 分布式配置中心架构设计的原理

###  Nacos如何实现服务器集群

### 9.18 注册中心设计Ap与CP区别

### 9.19 Eureka与Zookeeper的区别

### 9.20 Nacos与Eureka的区别

### 9.21 分布式一致性算法有那些

### 9.22 Nacos集群模式底层原理

### 9.23 raft协议底层实现原理

### 9.24 为什么要使用服务网关

### 9.25 过滤器与微服务网关的区别

### 9.26 Zuul网关与Gateway之间的区别

### 9.27  Nginx与网关之前存在那些区别

### 9.28  网关部署实现集群设计思路

### 9.29  如何实现GateWay动态网关

### 9.30  GateWay词汇表格有那些

### 9.31 GateWay网关谓词用法

### 9.32  GateWay如何解决网关跨域的问题

### 9.33  服务保护、服务限流、服务降级的概念

### 9.34  服务雪崩效应产生的背景

### 9.35  服务隔离机制信号量与线程池隔离

### 9.36  sentinel与hystrix的区别

### 9.37  sentinel如何实现对服务限流

### 9.38  sentinel实现限流的模式有那些

### 9.29  qps限流与并发限流之间的区别

## 10. 互联网安全架构设计

### 10.1 接口如何保证API的安全性的问题

### 10.2 在微服务架构中，如何保证接口的安全性

### 10.3  高并发的情况下，接口的代码会存在那些问题

### 10.4  你的项目中是如何记录请求的日志

### 10.5  如何防止ddos攻击请求



## 11 . 微服务电商项目实战

### 你在项目中遇到那些？你是怎么解决的？
### 登陆是如何实现的呢？
- #### 唯一登陆实现呢 ?

### 微信开发可能存在的问题
### 百万级定时消息推送模版的原理
